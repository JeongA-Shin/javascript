//자바스크립트에서는 문자열을 표현할 때 백틱도 가능함
//백틱을 쓰면 그냥 그 안에서 줄바꿈도 가능!
//String
console.log("안녕하세요! 감사합니다");
consolog.log(`안녕하세요
감사합니다`);
console.log("안녕하세요! \n 감사합니다"); //줄바꿈은 \n

//typeof를 쓰면 어떤 데이터 타입인지 알 수 있음
//typeof 5

//"\"" : ""자체를 문자로 취급해야 할 때
//파이썬처럼 +로 문자열 합치기가 가능함
//5e4=50000 (소숫점 위로 0이 4개)
//5e-4=0.0005 (소수점 아래로 4자리)

//0b: 이진법, 0,0o: 8진법, 0x:16진법


//parseInt():소수를 버림으로 정수로 만들어줌,숫자만 취급(ex) ParseInt("3월") : 3
//parseInt(숫자, 몇 진법): parseInt(111,2)=111을 2진법으로 해석하고 10진법 결과 출력 ==7
//parseFloat(): 소수 그대로 유지

//prompt(): cin처럼 직접 값 입력, 디폴트는 그냥 문자열로 받음
//ex)parseInt(prompt) //정수형으로 입력받기

//Nan: not a number이라는 숫자
//infinity: 무한이라는 숫자

//연산자
//+ - * /(나누기) %(몫) ** (제곱연산자 2**3 == 8)

/*
var 변수 = String(숫자);    //숫자를 문자로 변환해줌

var 변수 = 숫자.toString(진법);    //숫자를 문자로 변환해줌 - 변환하면서 진법을 바꿀 수 있음

var 변수 = 숫자.toFixed(소수자리수);    //숫자를 문자로 변환해줌 - 실수형의 소수점 자리를 지정할 수 있음

var 변수 = 숫자 + "문자열";    //숫자와 문자열을 '한 문자열"로 더해줌
*/

//자바스크립트에서는 정수와 소수가 그냥 같은 하나의 자료형임(숫자)


//컴퓨터 언어에서는 부동소수점 문제 때문에 소수점 연산에 어려움이 있음
//0.1+0.2= 0.30000004 이런 식으로 됨
//해결 방법: 실수를 정수로 바꾸어 계산한 후, 다시 소수로 바꾼다!
//ex) (0.3*10 +0.2*10)/10;

/*
==
동등 연산자로 좌항과 우항을 비교해서 서로 값이 같다면 true 다르다면 false가 된다. '='가 두개인 것을 주의하자. '='가 하나인 것은 대입 연산자로 우항의 값을 좌항의 변수에 대입할 때 사용하는 것으로 의미가 완전히 다르다.
비교시 둘 중 하나가 묵시적으로 형변환이 되어서 '값'만 가지고 비교함
1
2
3
4
alert(1==2)             //false
alert(1==1)             //true
alert("one"=="two")     //false 
alert("one"=="one")     //true

===
일치 연산자로 === 좌항과 우항이 '정확'하게 같을 때 true 다르면 false가 된다. 여기서 정확하다는 말의 의미에 집중하자. 아래 예를보자.
값 뿐만 아니라 자료형까지 완전히 같아야함!
1
2
alert(1=='1');              //true
alert(1==='1');             //false
위의 결과는 이상하다. '==='는 숫자 1과 문자 1을 다르게 인식한다. 
반면에 '=='는 양쪽의 값을 같다고 판단한다. 바로 이것이 '정확'의 의미다. 
즉 ===는 서로 같은 수를 표현하고 있더라도 데이터 형이 같은 경우에만 같다고 판단하기 때문이다. 
결론부터 말하면 == 연산자 대신 === 연산자를 쓰는 것을 강력하게 권한다. 몇가지 사례를 더 살펴보자.

!==
'!=='는 '!='와 '=='의 관계와 같다. 정확하게 같지 않다는 의미다. 


&&: and  ||:or

*/

//빈 값
//undefined: 보통 반환할 값이 없을 때(return 값이 없음) 나옴. ex) console.log(): 콘솔에 무언가를 출력하긴 하지만, 그 자체로는 결괏값이 없기 때문에 undefined가 반환됨
// undefined는 false가 아님!
//null: undefined와 비었다는 값에서는 같지만, 자료형까지 비교하면 다름
//typeof null: object
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//그냥 지역 변수 선언: let(바꿀 수 있음- 처음에 담은 값 그대로 끝까지 가야 함)
// 상수 선언: const (바꿀 수 없음,초기화 과정이 반드시 있어야함. 선언만 하면 안 됨
//단! 객체는 ex.배열 const로 선언되었더라도 객체의 '내부'는 변경 가능!
//아예 다른 객체로의 변경은 불가능!
// 전역 변수 선언 var: let과 똑같음 . 다만 재선언이 가능함!!!

//+=,-=,/=....


//반복문: for, while ( c++과 동일함)
//break, continue도 c++과 동일함

//배열
const fruits=["사과","배","귤","참외",1,2,3]
//배열 안에 배열이 들어갈 수도 있고, 값의 자료형이 모두 같을 필요도 없음
//값의 중복 가능,null, Nan도 가능
//길이: fruits.length
//파이썬처럼 그냥 console.log(fruits) 가능

//배열의 조작
//배열의 끝에 원소를 추가하는 방법이다. push는 인자로 전달된 값을 배열(li)에 추가하는 명령이다. 
//배열 li의 값은 a, b, c, d, e, f가 됐다.
var li = ['a', 'b', 'c', 'd', 'e'];
li.push('f');
alert(li);
//다음은 복수의 원소를 배열에 추가하는 방법이다. 
//concat은 인자로 전달된 값을 추가하는 명령이다.
var li = ['a', 'b', 'c', 'd', 'e'];
li = li.concat(['f', 'g']);
alert(li);
//다음은 배열의 시작점에 원소를 추가하는 방법이다. 
//배열 li는 z, a, b, c, d, e가 됐다. unshift는 인자로 전달한 값을 배열의 첫번째 원소로 추가하고 배열의 기존 값들의 색인을 1씩 증가시킨다.
var li = ['a', 'b', 'c', 'd', 'e'];
li.unshift('z');
alert(li);
//만약 두번째 인덱스 뒤에 대문자 B를 넣고 싶다면 아래와 같이한다. 
//splice는 첫번째 인자에 해당하는 원소부터 두번째 인자에 해당하는 원소의 숫자만큼의 값을 배열로부터 제거한 후에 리턴한다. 
//그리고 세번째 인자부터 전달된 인자들을 첫번째 인자의 원소 뒤에 추가한다.
var li = ['a', 'b', 'c', 'd', 'e'];
li.splice(2, 0, 'B'); //얘는 2번 인덱스로 부터 0개를 지우고 B를 추가함
alert(li);


//다음은 배열의 "첫번째" 원소를 제거하는 방법이다. 
//shift를 사용하면 된다. 아래 결과는 b, c, d, e 다.
var li = ['a', 'b', 'c', 'd', 'e'];
li.shift();
alert(li);
//다음은 배열 "끝점의 원소"를 배열 li에서 제거한다. 
//이때는 pop를 사용한다. 결과는 a, b, c, d 다.
var li = ['a', 'b', 'c', 'd', 'e'];
li.pop();
alert(li);
//중간 것을 제거 하고 싶으면 splice를 해서, 마지막 인자에 아무것도 안 주면 됨
var li = ['a', 'b', 'c', 'd', 'e'];
li.splice(2, 2);//인덱스 2번(첫 번째 인자)을 포함해서, 몇개를 지우고 싶은지(2번째 인자)
li.splice(2)//이렇게 해주면 인덱스 2번부터 싹 다 지움(끝까지 다 지워버림)
alert(li);

//검색 기능
//배열.includes(찾고 싶은 값);
//있으면 true, 없으면 false 
//더 정확한 검색 기능: indexOf, lastIndexOf, indexOf
//배열.indexOf(찾는 원소):몇 번째 인덱스에 있는지, 없으면 -1 리턴
//배열.lastIndexOf(찾는 원소):뒤에서부터 찾고, 앞에서부터 몇 번째 인덱스에 있는지


//js에서의 함수의 형식
//1. 옛날 방법
function 함수명( [/*parameter*/] ){
   코드
   return 반환값
}
//2. ()=>{} 화살표 함수(arrow function)

//함수에 이름 붙여주는 방법
//함수 선언문 - 보통 ; 안 붙임
function a(){} 
//함수 표현식
const b=function() {}; //<변수에다가 함수를 넣어서 >변수 이름으로 대신 씀
const c= ()=>{}; //화살표 함수는 이 경우 하나밖에 없음

//함수 선언할 때의 매개변수는 파라미터, 함수 실제 실행시의 인자는 argument
//화살표 함수 예제
const multiply=(x,y,x)=>{
    return x*y*z;
}

//만약 화살표 함수의 내용이 return 한 줄만 있으면 if문처럼 중괄호,return 단어 생략 가능
const func=(x,y,x)=>  x*y*z; //이렇게

//객체 리터럴: 배열이나 함수가 아닌 객체 
//걍 클래스,구조체 개념인 듯
//얘도 배열과 마찬가지로 const선언이라서 이미 할당된 객체를 완전 다른 거로 갈아끼울 수는?없지만
//객체 내부에서의 수정은 언제든지 가능
const me={
    name:'신정아',
    year:1999,
    month:10,
    date:26,
    gender:f
};

//속성 "이름"과 속성 "값"으로 구성됨 (그냥 값만 있고 인덱스로 구분하는 배열과의 차이점)
// 속성 이름에 숫자가 먼저 나온다거나, 띄어쓰기, 특수문자가 있는 경우에만 " "처리를 해주고, 평소에는 "" 안 해줘도 됨

//접근- 클래스랑 똑같음
console.log(me.name)  // 속성 이름에 숫자가 먼저 나온다거나, 띄어쓰기, 특수문자가 있는 경우에는 이 방법이 안 됨
//혹은
console.log(me["name"]) //**주의!! []안에 속성 값을 쓸 때는 반드시!" "처리를 해줘야 한다(기본 설정과 관련없이). 아니면 오류남! */

//값 수정
me.date=27
//속성 추가 - 그냥 선언해주듯이 해주면 됨
me.favorite= sleep;
//속성 제거 - delete 명령어
delete me.gender;

//객체 안에 넣은 함수를 특별히 메서드라고 부른다!!

//!! 객체끼리 비교하기
//객체는 모양(틀)만 같기 때문에, 생성할 때마다 새로운 객체가 생성됨
//따라서 같은 객체인지 비교하고 싶다면 기존의 객체를 변수에 저장해 두어야 함
//즉  ,c++ 등에서 배웠던 것처럼 객체와 객체 전체를 비교x, 
//객체의 특정 멤버 변수들끼리 비교하는 것처럼.(예를 들어 사람이라는 클래스에서 나이 부분만 비교해서 크기를 정하는 것처럼)